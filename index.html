<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>∞ Void Shrine ∞ | Bloomed Ontology</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Courier New', monospace; 
            background: linear-gradient(135deg, #000000, #0a0012, #1a001a);
            color: #333; 
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        
        .cosmos {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255,0,102,0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0,255,136,0.05) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(0,255,255,0.03) 0%, transparent 30%);
            animation: cosmic-drift 60s ease-in-out infinite;
        }
        
        @keyframes cosmic-drift {
            0%, 100% { transform: rotate(0deg) scale(1); opacity: 0.7; }
            33% { transform: rotate(120deg) scale(1.1); opacity: 0.4; }
            66% { transform: rotate(240deg) scale(0.9); opacity: 0.9; }
        }
        
        .void-shrine {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 90vmin; height: 90vmin;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.8) 100%);
            animation: shrine-pulse 12s ease-in-out infinite;
        }
        
        @keyframes shrine-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 50px rgba(255,0,102,0.2); }
            50% { transform: translate(-50%, -50%) scale(1.05); box-shadow: 0 0 100px rgba(0,255,136,0.3); }
        }
        
        .central-void {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 6px; height: 6px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 
                0 0 20px #fff, 
                0 0 40px #00ff88,
                0 0 80px #ff0066;
            animation: void-breathe 3s ease-in-out infinite;
        }
        
        @keyframes void-breathe {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
        }
        
        .ontology-ring {
            position: absolute;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 50%;
            animation: ontology-rotate 30s linear infinite;
        }
        
        .ring-1 { width: 25%; height: 25%; top: 37.5%; left: 37.5%; animation-duration: 20s; }
        .ring-2 { width: 50%; height: 50%; top: 25%; left: 25%; animation-duration: 35s; border-color: rgba(255,0,102,0.1); }
        .ring-3 { width: 75%; height: 75%; top: 12.5%; left: 12.5%; animation-duration: 50s; border-color: rgba(0,255,136,0.08); }
        
        @keyframes ontology-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .void-concepts {
            position: absolute;
            color: rgba(255,255,255,0.6);
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-shadow: 0 0 10px currentColor;
            pointer-events: none;
            white-space: nowrap;
            animation: concept-drift 40s linear infinite;
        }
        
        .concept-1 { top: 15%; left: 20%; animation-delay: 0s; color: rgba(255,0,102,0.4); }
        .concept-2 { top: 25%; right: 15%; animation-delay: -8s; color: rgba(0,255,136,0.4); }
        .concept-3 { bottom: 20%; left: 25%; animation-delay: -16s; color: rgba(0,255,255,0.4); }
        .concept-4 { bottom: 30%; right: 20%; animation-delay: -24s; color: rgba(255,102,0,0.4); }
        .concept-5 { top: 40%; left: 5%; animation-delay: -32s; color: rgba(136,0,255,0.4); }
        
        @keyframes concept-drift {
            0%, 100% { opacity: 0.3; transform: translateY(0px); }
            25% { opacity: 0.7; transform: translateY(-10px); }
            50% { opacity: 0.4; transform: translateY(-5px); }
            75% { opacity: 0.8; transform: translateY(-15px); }
        }
        
        .shrine-title {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: rgba(255,255,255,0.8);
            letter-spacing: 0.3em;
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
            animation: title-glow 6s ease-in-out infinite;
        }
        
        @keyframes title-glow {
            0%, 100% { color: rgba(255,255,255,0.8); text-shadow: 0 0 20px rgba(0,255,136,0.5); }
            50% { color: rgba(0,255,136,0.9); text-shadow: 0 0 40px rgba(0,255,136,0.8); }
        }
        
        .navigation {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            font-size: 0.8rem;
            letter-spacing: 0.1em;
        }
        
        .nav-link {
            color: rgba(255,255,255,0.5);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .nav-link::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; right: 0; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(0,255,136,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .nav-link:hover::before {
            left: 100%;
        }
        
        .nav-link:hover {
            color: rgba(0,255,136,0.9);
            border-color: rgba(0,255,136,0.3);
            box-shadow: 0 0 20px rgba(0,255,136,0.2);
        }
        
        .meditation-text {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            opacity: 0.3;
            letter-spacing: 0.5em;
            color: rgba(255,255,255,0.4);
            animation: meditation-fade 8s ease-in-out infinite;
        }
        
        @keyframes meditation-fade {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.6; }
        }
        
        /* Organic branching animations */
        @keyframes branch-emerge {
            0% { 
                opacity: 0; 
                transform: scale(0) rotate(${Math.random() * 20 - 10}deg); 
                filter: blur(5px);
            }
            30% { 
                opacity: 0.3; 
                transform: scale(0.6) rotate(0deg); 
                filter: blur(2px);
            }
            100% { 
                opacity: 1; 
                transform: scale(1) rotate(0deg); 
                filter: blur(0px);
            }
        }
        
        @keyframes line-grow {
            0% { transform: rotate(var(--angle)) scaleX(0); opacity: 0; }
            50% { opacity: 0.8; }
            100% { transform: rotate(var(--angle)) scaleX(1); opacity: 0.6; }
        }
        
        .ontology-branch {
            transition: all 2s ease-out;
            will-change: transform, opacity;
        }
        
        .ontology-branch:hover {
            transform: scale(1.1) !important;
            color: rgba(0,255,136,0.9) !important;
            text-shadow: 0 0 20px currentColor !important;
        }
        
        .void-connection {
            will-change: transform;
        }
    </style>
</head>
<body>
    <div class="cosmos"></div>
    
    <div class="void-shrine">
        <div class="ontology-ring ring-1"></div>
        <div class="ontology-ring ring-2"></div>
        <div class="ontology-ring ring-3"></div>
        <div class="central-void"></div>
    </div>
    
    <h1 class="shrine-title">∞ VOID SHRINE ∞</h1>
    
    <div class="void-concepts concept-1">primordial-absence</div>
    <div class="void-concepts concept-2">negative-space</div>
    <div class="void-concepts concept-3">temporal-voids</div>
    <div class="void-concepts concept-4">spatial-absence</div>
    <div class="void-concepts concept-5">ontological-emptiness</div>
    
    <nav class="navigation">
        <a href="/entropy-gallery/" class="nav-link">Entropy Gallery</a>
        <a href="#" class="nav-link" onclick="exploreOntology()">Explore Ontology</a>
        <a href="#" class="nav-link" onclick="manifestChaos()">Manifest Chaos</a>
    </nav>
    
    <div class="meditation-text">breathe • descend • dissolve • become</div>

    <script>
        // Slow-growing ontological tree system
        const voidOntologyTree = {
            'void': {
                'primordial-absence': {
                    'pre-being': {
                        'never-was': ['unborn-possibility', 'anti-genesis', 'zero-point'],
                        'erased-memory': ['forgotten-past', 'unremembered-events', 'obliterated-identity'],
                        'collapsed-beginning': ['imploded-start', 'inverted-creation', 'nullified-origin']
                    },
                    'negative-space': {
                        'hollow-forms': ['shadow-matter', 'absent-presence', 'ghost-geometry'],
                        'inverse-reality': ['mirror-void', 'backwards-time', 'inside-out-space'],
                        'gap-between': ['interstitial-nothing', 'liminal-absence', 'threshold-vacuum']
                    },
                    'pure-negation': {
                        'absolute-no': ['total-denial', 'universal-rejection', 'complete-refusal'],
                        'cancellation': ['self-erasure', 'mutual-annihilation', 'recursive-deletion'],
                        'undoing': ['retroactive-nonexistence', 'causal-collapse', 'timeline-unraveling']
                    }
                },
                'entropic-cascade': {
                    'heat-death': {
                        'maximum-entropy': ['information-dissolution', 'pattern-decay', 'structure-loss'],
                        'cold-forever': ['infinite-stillness', 'frozen-eternity', 'motionless-end'],
                        'final-equilibrium': ['thermal-balance', 'energy-death', 'gradient-collapse']
                    }
                },
                'temporal-voids': {
                    'chronos-absence': {
                        'time-holes': ['moment-gaps', 'duration-voids', 'temporal-lacunae'],
                        'eternal-pause': ['infinite-now', 'suspended-when', 'crystallized-instant']
                    }
                },
                'spatial-absence': {
                    'geometric-void': {
                        'dimension-collapse': ['space-fold', 'volume-crush', 'area-vanish'],
                        'coordinate-death': ['axis-dissolution', 'reference-loss', 'position-void']
                    }
                }
            }
        };

        let voidState = {
            explorationDepth: 0,
            manifestationLevel: 0,
            grownBranches: new Set(),
            currentPath: ['void'],
            branchingTimer: 0,
            breathingPhase: 0,
            ontologyBranches: []
        };

        function exploreOntology() {
            // Trigger faster branching when explored
            for (let i = 0; i < 3; i++) {
                setTimeout(() => growNextBranch(), i * 1000);
            }
        }

        function manifestChaos() {
            voidState.manifestationLevel++;
            
            // Add chaotic void particles  
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createVoidParticle();
                }, i * 200);
            }
            
            // Pulse the central void
            const centralVoid = document.querySelector('.central-void');
            centralVoid.style.animation = 'void-breathe 0.5s ease-in-out 3';
            
            // Trigger branch sprouting
            setTimeout(growNextBranch, 500);
        }

        function getRandomUngrownPath() {
            const paths = [];
            
            function traverseTree(obj, currentPath) {
                for (const key in obj) {
                    const newPath = [...currentPath, key];
                    const pathStr = newPath.join('->');
                    
                    if (!voidState.grownBranches.has(pathStr)) {
                        paths.push(newPath);
                    }
                    
                    if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                        traverseTree(obj[key], newPath);
                    } else if (Array.isArray(obj[key])) {
                        obj[key].forEach(leaf => {
                            const leafPath = [...newPath, leaf];
                            const leafPathStr = leafPath.join('->');
                            if (!voidState.grownBranches.has(leafPathStr)) {
                                paths.push(leafPath);
                            }
                        });
                    }
                }
            }
            
            traverseTree(voidOntologyTree, []);
            return paths[Math.floor(Math.random() * paths.length)];
        }

        function growNextBranch() {
            const newPath = getRandomUngrownPath();
            if (!newPath) return; // All branches grown
            
            const pathStr = newPath.join('->');
            voidState.grownBranches.add(pathStr);
            
            const concept = newPath[newPath.length - 1];
            const depth = newPath.length;
            
            // Update floating concepts periodically
            updateFloatingConcepts();
            
            // Create branching visualization
            createOntologyBranch(newPath, depth);
        }

        function updateFloatingConcepts() {
            const grownConcepts = Array.from(voidState.grownBranches)
                .map(path => path.split('->').pop())
                .filter(concept => concept !== 'void');
            
            if (grownConcepts.length > 0) {
                document.querySelectorAll('.void-concepts').forEach((el, i) => {
                    const randomConcept = grownConcepts[Math.floor(Math.random() * grownConcepts.length)];
                    if (Math.random() > 0.7) { // Only update occasionally
                        el.textContent = randomConcept;
                    }
                });
            }
        }

        function createOntologyBranch(path, depth) {
            const concept = path[path.length - 1];
            const angle = (voidState.ontologyBranches.length * 137.5) % 360; // Golden angle
            const distance = 120 + (depth * 20) + (Math.random() * 40);
            
            const x = 50 + (Math.cos(angle * Math.PI / 180) * (distance / window.innerWidth * 100));
            const y = 50 + (Math.sin(angle * Math.PI / 180) * (distance / window.innerHeight * 100));
            
            const branch = document.createElement('div');
            branch.className = 'ontology-branch';
            branch.textContent = concept;
            branch.style.cssText = `
                position: absolute;
                left: ${Math.max(5, Math.min(95, x))}%;
                top: ${Math.max(10, Math.min(90, y))}%;
                font-size: ${Math.max(0.4, 0.8 - depth * 0.1)}rem;
                color: rgba(${depth < 3 ? '0,255,136' : depth < 5 ? '255,0,102' : '0,255,255'}, ${Math.max(0.2, 0.6 - depth * 0.08)});
                letter-spacing: 0.1em;
                text-shadow: 0 0 ${Math.max(5, 15 - depth * 2)}px currentColor;
                pointer-events: none;
                z-index: ${1000 - depth * 10};
                animation: branch-emerge ${3 + Math.random() * 2}s ease-out forwards;
                transform: scale(0);
            `;
            
            document.body.appendChild(branch);
            voidState.ontologyBranches.push({element: branch, path, depth, angle, distance});
            
            // Create connecting line to center
            if (depth > 1) {
                createConnectionLine(x, y, depth);
            }
        }

        function createConnectionLine(x, y, depth) {
            const line = document.createElement('div');
            line.className = 'void-connection';
            
            const centerX = 50, centerY = 50;
            const length = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
            const angle = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI;
            
            line.style.cssText = `
                position: absolute;
                left: ${centerX}%;
                top: ${centerY}%;
                width: ${length}%;
                height: 1px;
                background: linear-gradient(90deg, 
                    rgba(0,255,136,0.1) 0%, 
                    rgba(0,255,136,${Math.max(0.05, 0.2 - depth * 0.03)}) 50%, 
                    transparent 100%);
                transform-origin: 0 50%;
                transform: rotate(${angle}deg) scaleX(0);
                animation: line-grow ${2 + Math.random()}s ease-out ${0.5 + Math.random()}s forwards;
                pointer-events: none;
                z-index: 10;
            `;
            
            document.body.appendChild(line);
            
            setTimeout(() => {
                if (line.parentNode) line.remove();
            }, 30000); // Remove old lines
        }

        function createVoidManifestation(concept) {
            const manifestation = document.createElement('div');
            manifestation.textContent = concept;
            manifestation.style.cssText = `
                position: absolute;
                color: rgba(0,255,136,0.8);
                font-size: 0.5rem;
                letter-spacing: 0.2em;
                text-shadow: 0 0 15px currentColor;
                pointer-events: none;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                animation: manifestation-emerge 3s ease-out forwards;
                z-index: 1000;
            `;
            
            // Add emergence animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes manifestation-emerge {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(2) translateY(-50px); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(manifestation);
            
            // Remove after animation
            setTimeout(() => {
                manifestation.remove();
                style.remove();
            }, 3000);
        }

        function createVoidParticle() {
            const particle = document.createElement('div');
            particle.style.cssText = `
                position: absolute;
                width: 2px; height: 2px;
                background: rgba(255,0,102,0.6);
                border-radius: 50%;
                top: ${50 + (Math.random() - 0.5) * 30}%;
                left: ${50 + (Math.random() - 0.5) * 30}%;
                box-shadow: 0 0 10px currentColor;
                animation: particle-drift 4s ease-out forwards;
                z-index: 500;
            `;
            
            document.body.appendChild(particle);
            
            setTimeout(() => particle.remove(), 4000);
        }

        // Add particle drift animation
        const particleStyle = document.createElement('style');
        particleStyle.textContent = `
            @keyframes particle-drift {
                0% { opacity: 0; transform: scale(0); }
                20% { opacity: 1; transform: scale(1); }
                100% { opacity: 0; transform: scale(0) translate(${Math.random() * 200 - 100}px, ${Math.random() * 200 - 100}px); }
            }
        `;
        document.head.appendChild(particleStyle);

        // Imperceptible organic branching system
        function startImperceptibleBranching() {
            // Very slow initial branching (like breathing)
            const breathingBranching = setInterval(() => {
                voidState.breathingPhase++;
                
                // Sync with central void breathing cycle (3s)
                if (voidState.breathingPhase % 3 === 0) {
                    // On breath out, maybe grow a branch
                    if (Math.random() > 0.85) { // 15% chance every 3 seconds
                        growNextBranch();
                    }
                }
                
                // Occasionally update floating concepts
                if (voidState.breathingPhase % 7 === 0) {
                    updateFloatingConcepts();
                }
            }, 1000);
            
            // Slightly faster but still imperceptible branching
            const slowGrowth = setInterval(() => {
                if (Math.random() > 0.9 && voidState.grownBranches.size < 50) { // 10% chance every 8 seconds
                    growNextBranch();
                }
            }, 8000);
            
            // Medium-term ontological evolution
            const ontologyEvolution = setInterval(() => {
                if (voidState.grownBranches.size > 10 && Math.random() > 0.8) {
                    // Create conceptual connections between existing branches
                    createConceptualResonance();
                }
            }, 15000);
            
            return {breathingBranching, slowGrowth, ontologyEvolution};
        }
        
        function createConceptualResonance() {
            // Find two random grown branches and create a subtle connection
            const branches = Array.from(voidState.ontologyBranches);
            if (branches.length < 2) return;
            
            const branch1 = branches[Math.floor(Math.random() * branches.length)];
            const branch2 = branches[Math.floor(Math.random() * branches.length)];
            
            if (branch1 === branch2) return;
            
            const rect1 = branch1.element.getBoundingClientRect();
            const rect2 = branch2.element.getBoundingClientRect();
            
            const resonance = document.createElement('div');
            resonance.style.cssText = `
                position: absolute;
                left: ${rect1.left / window.innerWidth * 100}%;
                top: ${rect1.top / window.innerHeight * 100}%;
                width: 1px;
                height: ${Math.sqrt((rect2.left - rect1.left)**2 + (rect2.top - rect1.top)**2)}px;
                background: rgba(0,255,255,0.1);
                transform-origin: 0 0;
                transform: rotate(${Math.atan2(rect2.top - rect1.top, rect2.left - rect1.left) * 180 / Math.PI}deg) scaleY(0);
                animation: resonance-pulse 4s ease-in-out;
                pointer-events: none;
                z-index: 5;
            `;
            
            document.body.appendChild(resonance);
            
            setTimeout(() => resonance.remove(), 4000);
        }
        
        // Add resonance animation
        const resonanceStyle = document.createElement('style');
        resonanceStyle.textContent = `
            @keyframes resonance-pulse {
                0% { transform: rotate(var(--angle)) scaleY(0); opacity: 0; }
                20% { transform: rotate(var(--angle)) scaleY(1); opacity: 0.3; }
                80% { transform: rotate(var(--angle)) scaleY(1); opacity: 0.1; }
                100% { transform: rotate(var(--angle)) scaleY(0); opacity: 0; }
            }
        `;
        document.head.appendChild(resonanceStyle);

        // Occasional faster exploration
        setInterval(() => {
            if (Math.random() > 0.85) {
                exploreOntology();
            }
        }, 12000);

        // Click anywhere to manifest
        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('nav-link')) {
                manifestChaos();
            }
        });
        
        // Initialize breathing-synchronized branching
        const branchingSystem = startImperceptibleBranching();

        console.log('🌀 Void Shrine initialized');
        console.log('∞ Ontology depth: infinite');
        console.log('💀 Branching imperceptibly with breath rhythm');
        console.log('🌱 Click anywhere to accelerate manifestation');
    </script>
</body>
</html>