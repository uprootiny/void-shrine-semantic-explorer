<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>🌀 Agent Orchestrator: Multi-LLM Command Matrix</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            background: radial-gradient(ellipse at center, #000510 0%, #0a0a1e 30%, #000000 100%);
            color: #e0e0ff;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            overflow-x: hidden;
            overflow-y: auto;
            min-height: 100vh;
            position: relative;
            -webkit-overflow-scrolling: touch;
        }
        
        .cosmic-void {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                radial-gradient(2px 2px at 20px 30px, #ffffff, transparent),
                radial-gradient(2px 2px at 40px 70px, #ffffff, transparent),
                radial-gradient(1px 1px at 90px 40px, #ffffff, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: stars 20s linear infinite;
            opacity: 0.3;
        }
        
        @keyframes stars {
            from { transform: translateY(0px); }
            to { transform: translateY(-100px); }
        }
        
        .orchestrator-grid {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-areas:
                "header header header header"
                "tactical science ops engineering"
                "creative research analysis support"
                "monitor prompt controls results";
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: auto repeat(3, 300px) 200px;
            gap: 15px;
            padding: 20px;
            min-height: 100vh;
        }
        
        .header-panel {
            grid-area: header;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2) 0%, rgba(0, 0, 0, 0.8) 100%);
            border: 3px solid transparent;
            border-image: linear-gradient(45deg, #8a2be2, #ff6b6b, #00ffaa, #8a2be2) 1;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        
        .header-title {
            font-size: 2rem;
            font-weight: bold;
            color: #8a2be2;
            text-shadow: 0 0 30px currentColor;
            margin-bottom: 10px;
        }
        
        .system-status {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
        }
        
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.8rem;
        }
        
        .status-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00ffaa;
        }
        
        .agent-station {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
            border: 2px solid var(--agent-color);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(var(--agent-rgb), 0.2);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .agent-station::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; height: 3px;
            background: linear-gradient(90deg, transparent, var(--agent-color), transparent);
            animation: agent-scan 3s infinite;
        }
        
        @keyframes agent-scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .tactical { 
            grid-area: tactical; 
            --agent-color: #ff4444; 
            --agent-rgb: 255, 68, 68;
        }
        .science { 
            grid-area: science; 
            --agent-color: #4488ff; 
            --agent-rgb: 68, 136, 255;
        }
        .ops { 
            grid-area: ops; 
            --agent-color: #00ffaa; 
            --agent-rgb: 0, 255, 170;
        }
        .engineering { 
            grid-area: engineering; 
            --agent-color: #ffaa00; 
            --agent-rgb: 255, 170, 0;
        }
        .creative { 
            grid-area: creative; 
            --agent-color: #ff6b6b; 
            --agent-rgb: 255, 107, 107;
        }
        .research { 
            grid-area: research; 
            --agent-color: #4ecdc4; 
            --agent-rgb: 78, 205, 196;
        }
        .analysis { 
            grid-area: analysis; 
            --agent-color: #45b7d1; 
            --agent-rgb: 69, 183, 209;
        }
        .support { 
            grid-area: support; 
            --agent-color: #96ceb4; 
            --agent-rgb: 150, 206, 180;
        }
        
        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .agent-name {
            font-weight: bold;
            color: var(--agent-color);
            text-shadow: 0 0 10px var(--agent-color);
        }
        
        .agent-status {
            background: var(--agent-color);
            color: black;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
        }
        
        .agent-model {
            font-size: 0.7em;
            opacity: 0.8;
            margin-bottom: 8px;
        }
        
        .agent-response {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            font-size: 0.8em;
            line-height: 1.4;
            flex: 1;
            overflow-y: auto;
            max-height: 150px;
        }
        
        .agent-controls {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .agent-button {
            background: rgba(var(--agent-rgb), 0.2);
            border: 1px solid var(--agent-color);
            color: var(--agent-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.6em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .agent-button:hover {
            background: var(--agent-color);
            color: black;
        }
        
        .monitor-panel {
            grid-area: monitor;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #8a2be2;
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }
        
        .prompt-panel {
            grid-area: prompt;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffaa;
            border-radius: 15px;
            padding: 15px;
        }
        
        .controls-panel {
            grid-area: controls;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff6b6b;
            border-radius: 15px;
            padding: 15px;
        }
        
        .results-panel {
            grid-area: results;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffaa00;
            border-radius: 15px;
            padding: 15px;
        }
        
        .panel-title {
            font-weight: bold;
            color: inherit;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        .prompt-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffaa;
            border-radius: 10px;
            padding: 10px;
            color: #e0e0ff;
            font-family: inherit;
            font-size: 0.8em;
            resize: vertical;
            min-height: 80px;
        }
        
        .prompt-input:focus {
            outline: none;
            border-color: #8a2be2;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
        }
        
        .config-section {
            margin-bottom: 15px;
        }
        
        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 0.7em;
        }
        
        .config-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #666;
            color: #e0e0ff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: inherit;
            font-size: inherit;
            width: 60%;
        }
        
        .config-input:focus {
            outline: none;
            border-color: #8a2be2;
        }
        
        .execute-button {
            background: #8a2be2;
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .execute-button:hover {
            background: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .metrics-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 0.7em;
        }
        
        .metric-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }
        
        .metric-value {
            font-weight: bold;
            color: #00ffaa;
            font-size: 1.1em;
        }
        
        .log-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 8px;
            height: 100px;
            overflow-y: auto;
            font-size: 0.65em;
            line-height: 1.3;
        }
        
        .log-entry {
            margin: 2px 0;
            opacity: 0.8;
        }
        
        .log-entry.system { color: #8a2be2; }
        .log-entry.agent { color: #00ffaa; }
        .log-entry.error { color: #ff4444; }
        
        @media (max-width: 1200px) {
            .orchestrator-grid {
                grid-template-areas:
                    "header header"
                    "tactical science"
                    "ops engineering"
                    "creative research"
                    "analysis support"
                    "monitor prompt"
                    "controls results";
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .orchestrator-grid {
                grid-template-areas:
                    "header"
                    "tactical"
                    "science"
                    "ops"
                    "engineering"
                    "creative"
                    "research"
                    "analysis"
                    "support"
                    "monitor"
                    "prompt"
                    "controls"
                    "results";
                grid-template-columns: 1fr;
            }
        }
        
        .secrets-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #8a2be2;
            border-radius: 6px;
            padding: 8px;
            font-size: 0.6em;
        }
        
        .secret-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 2px 0;
        }
        
        .secret-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #ff4444;
        }
        
        .secret-dot.active {
            background: #00ffaa;
            box-shadow: 0 0 6px currentColor;
        }
        
        .health-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .health-dot.healthy {
            background: #00ffaa;
            box-shadow: 0 0 4px #00ffaa;
        }
        
        .health-dot.warning {
            background: #ffaa00;
            box-shadow: 0 0 4px #ffaa00;
        }
        
        .conversation-memory {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            max-height: 120px;
            overflow-y: auto;
            font-size: 0.7em;
            border-left: 3px solid var(--agent-color);
        }
        
        .memory-entry {
            margin: 4px 0;
            padding: 4px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 3px;
        }
        
        .coordination-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8a2be2;
            border-radius: 10px;
            padding: 15px;
            width: 300px;
            z-index: 999;
            display: none;
        }
        
        .coordination-mode {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8a2be2;
            color: #8a2be2;
            padding: 6px 12px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
            font-size: 0.7em;
            display: inline-block;
        }
        
        .coordination-mode:hover {
            background: rgba(138, 43, 226, 0.4);
        }
        
        .coordination-mode.active {
            background: #8a2be2;
            color: white;
        }
    </style>
</head>
<body>
    <div class="cosmic-void"></div>
    
    <div class="secrets-status">
        <div class="secret-indicator">
            <div class="secret-dot active" id="envSecrets"></div>
            <span>ENV Secrets</span>
        </div>
        <div class="secret-indicator">
            <div class="secret-dot" id="githubSecrets"></div>
            <span>GitHub Secrets</span>
        </div>
        <div class="secret-indicator">
            <div class="secret-dot" id="dockerSecrets"></div>
            <span>Docker Secrets</span>
        </div>
        <div class="secret-indicator">
            <div class="secret-dot active" id="localSecrets"></div>
            <span>Local Config</span>
        </div>
    </div>
    
    <div class="orchestrator-grid">
        <div class="header-panel">
            <div class="header-title">🌀 Multi-LLM Agent Orchestrator</div>
            <div>Advanced AI swarm coordination with OpenRouter integration</div>
            <div class="system-status">
                <div class="status-item">
                    <div class="status-value" id="activeAgents">8</div>
                    <div>Active Agents</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="totalRequests">0</div>
                    <div>Total Requests</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="avgLatency">0ms</div>
                    <div>Avg Latency</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="coherence">87%</div>
                    <div>Swarm Coherence</div>
                </div>
            </div>
        </div>
        
        <div class="agent-station tactical">
            <div class="agent-header">
                <div class="agent-name">🎯 TACTICAL COMMANDER</div>
                <div class="agent-status" id="tacticalStatus">READY</div>
            </div>
            <div class="agent-model">Model: Claude 3.5 Sonnet</div>
            <div class="agent-response" id="tacticalResponse">
                Standing by for strategic analysis and tactical coordination. Specialized in threat assessment, resource allocation, and decisive action planning.
            </div>
            <div class="conversation-memory" id="tacticalMemory">
                <div class="memory-entry">🧠 Memory initialized - ready for context retention</div>
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('tactical')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('tactical')">RESET</button>
                <button class="agent-button" onclick="testAgent('tactical')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station science">
            <div class="agent-header">
                <div class="agent-name">🔬 SCIENCE ANALYST</div>
                <div class="agent-status" id="scienceStatus">READY</div>
            </div>
            <div class="agent-model">Model: GPT-4</div>
            <div class="agent-response" id="scienceResponse">
                Analytical protocols active. Ready for deep pattern recognition, hypothesis generation, and systematic investigation of complex problems.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('science')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('science')">RESET</button>
                <button class="agent-button" onclick="testAgent('science')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station ops">
            <div class="agent-header">
                <div class="agent-name">⚡ OPERATIONS</div>
                <div class="agent-status" id="opsStatus">READY</div>
            </div>
            <div class="agent-model">Model: Llama 3.1 405B</div>
            <div class="agent-response" id="opsResponse">
                Execution engines online. Coordinating systematic implementation of strategies across all operational vectors. Ready for deployment.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('ops')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('ops')">RESET</button>
                <button class="agent-button" onclick="testAgent('ops')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station engineering">
            <div class="agent-header">
                <div class="agent-name">🔧 ENGINEERING</div>
                <div class="agent-status" id="engineeringStatus">READY</div>
            </div>
            <div class="agent-model">Model: Gemini Pro</div>
            <div class="agent-response" id="engineeringResponse">
                Systems architecture initialized. Ready for technical implementation, infrastructure design, and scalable solution construction.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('engineering')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('engineering')">RESET</button>
                <button class="agent-button" onclick="testAgent('engineering')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station creative">
            <div class="agent-header">
                <div class="agent-name">🎨 CREATIVE SYNTHESIS</div>
                <div class="agent-status" id="creativeStatus">READY</div>
            </div>
            <div class="agent-model">Model: GPT-4 Turbo</div>
            <div class="agent-response" id="creativeResponse">
                Creative matrices active. Generating novel approaches, artistic solutions, and innovative perspectives on complex challenges.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('creative')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('creative')">RESET</button>
                <button class="agent-button" onclick="testAgent('creative')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station research">
            <div class="agent-header">
                <div class="agent-name">📚 RESEARCH</div>
                <div class="agent-status" id="researchStatus">READY</div>
            </div>
            <div class="agent-model">Model: Claude 3 Opus</div>
            <div class="agent-response" id="researchResponse">
                Research protocols engaged. Conducting deep investigation, knowledge synthesis, and comprehensive analysis across domains.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('research')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('research')">RESET</button>
                <button class="agent-button" onclick="testAgent('research')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station analysis">
            <div class="agent-header">
                <div class="agent-name">📊 ANALYSIS ENGINE</div>
                <div class="agent-status" id="analysisStatus">READY</div>
            </div>
            <div class="agent-model">Model: Mixtral 8x7B</div>
            <div class="agent-response" id="analysisResponse">
                Data processing systems online. Performing statistical analysis, trend identification, and quantitative assessment protocols.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('analysis')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('analysis')">RESET</button>
                <button class="agent-button" onclick="testAgent('analysis')">TEST</button>
            </div>
        </div>
        
        <div class="agent-station support">
            <div class="agent-header">
                <div class="agent-name">🛠️ SUPPORT SYSTEMS</div>
                <div class="agent-status" id="supportStatus">READY</div>
            </div>
            <div class="agent-model">Model: Perplexity 70B</div>
            <div class="agent-response" id="supportResponse">
                Support infrastructure active. Monitoring system health, optimizing performance, and ensuring operational resilience.
            </div>
            <div class="agent-controls">
                <button class="agent-button" onclick="focusAgent('support')">FOCUS</button>
                <button class="agent-button" onclick="resetAgent('support')">RESET</button>
                <button class="agent-button" onclick="testAgent('support')">TEST</button>
            </div>
        </div>
        
        <div class="monitor-panel">
            <div class="panel-title" style="color: #8a2be2;">📊 System Monitor</div>
            <div class="metrics-display">
                <div class="metric-item">
                    <div class="metric-value" id="requestsPerMin">0</div>
                    <div>Req/Min</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value" id="errorRate">0%</div>
                    <div>Error Rate</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value" id="tokenUsage">0K</div>
                    <div>Tokens Used</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value" id="costEstimate">$0.00</div>
                    <div>Est. Cost</div>
                </div>
            </div>
            <div class="progress-graphs">
                <canvas id="performanceChart" width="200" height="100" style="background: rgba(0,0,0,0.3); border-radius: 5px; margin-top: 10px;"></canvas>
                <div class="health-indicators" style="display: flex; gap: 5px; margin-top: 10px;">
                    <div class="health-dot" id="mcpHealth" title="MCP Service"></div>
                    <div class="health-dot" id="ragHealth" title="RAG Engine"></div>
                    <div class="health-dot" id="chaosHealth" title="Chaos System"></div>
                    <div class="health-dot" id="moralHealth" title="Moral Recentering"></div>
                </div>
            </div>
        </div>
        
        <div class="prompt-panel">
            <div class="panel-title" style="color: #00ffaa;">💭 Command Prompt</div>
            <textarea class="prompt-input" id="mainPrompt" 
                placeholder="Enter your multi-agent command here... The swarm awaits your instruction..."></textarea>
        </div>
        
        <div class="controls-panel">
            <div class="panel-title" style="color: #ff6b6b;">🎛️ Controls</div>
            <div class="config-section">
                <div class="config-row">
                    <label>Parallel Execution:</label>
                    <input type="checkbox" id="parallelMode" checked>
                </div>
                <div class="config-row">
                    <label>Response Synthesis:</label>
                    <input type="checkbox" id="synthesisMode" checked>
                </div>
                <div class="config-row">
                    <label>Max Tokens:</label>
                    <input type="number" class="config-input" id="maxTokens" value="2000" min="100" max="4000">
                </div>
                <div class="config-row">
                    <label>Temperature:</label>
                    <input type="range" class="config-input" id="temperature" min="0" max="2" step="0.1" value="0.7">
                </div>
                <div class="config-row">
                    <label>API Key Status:</label>
                    <span id="apiKeyStatus" style="color: #ff4444;">Not Set</span>
                </div>
            </div>
            <button class="execute-button" onclick="executeSwarmCommand()">
                🚀 EXECUTE SWARM COMMAND
            </button>
            <button class="agent-button" onclick="showConfigPanel()" style="margin-top: 8px; width: 100%; background: rgba(138, 43, 226, 0.2); border: 1px solid #8a2be2; color: #8a2be2;">
                ⚙️ API CONFIGURATION
            </button>
            <button class="agent-button" onclick="runOrchestrationScenarios()" style="margin-top: 8px; width: 100%; background: rgba(255, 107, 107, 0.2); border: 1px solid #ff6b6b; color: #ff6b6b;">
                🎭 ORCHESTRATION SCENARIOS
            </button>
            <button class="agent-button" onclick="runPromptTests()" style="margin-top: 8px; width: 100%; background: rgba(0, 255, 170, 0.2); border: 1px solid #00ffaa; color: #00ffaa;">
                🧪 RUN PROMPT TESTS
            </button>
            <button class="agent-button" onclick="toggleCoordinationPanel()" style="margin-top: 8px; width: 100%; background: rgba(255, 170, 0, 0.2); border: 1px solid #ffaa00; color: #ffaa00;">
                🎛️ COORDINATION MODES
            </button>
            <button class="agent-button" onclick="exportConfiguration()" style="margin-top: 8px; width: 100%; background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4;">
                💾 EXPORT CONFIG
            </button>
        </div>
        
        <div class="results-panel">
            <div class="panel-title" style="color: #ffaa00;">📋 Activity Log</div>
            <div class="log-display" id="activityLog">
                <div class="log-entry system">[SYSTEM] Agent orchestrator initialized</div>
                <div class="log-entry system">[SYSTEM] OpenRouter API configured</div>
                <div class="log-entry system">[SYSTEM] 8 agents ready for deployment</div>
                <div class="log-entry system">[SYSTEM] Secrets management active</div>
            </div>
        </div>
    </div>
    
    <div class="coordination-panel" id="coordinationPanel">
        <div class="panel-title" style="color: #8a2be2; margin-bottom: 10px;">🎛️ Agent Coordination Modes</div>
        <div class="coordination-mode" onclick="setCoordinationMode('sequential')">🔄 Sequential</div>
        <div class="coordination-mode active" onclick="setCoordinationMode('parallel')">⚡ Parallel</div>
        <div class="coordination-mode" onclick="setCoordinationMode('pipeline')">🔗 Pipeline</div>
        <div class="coordination-mode" onclick="setCoordinationMode('consensus')">🤝 Consensus</div>
        <div class="coordination-mode" onclick="setCoordinationMode('competitive')">🏆 Competitive</div>
        <div class="coordination-mode" onclick="setCoordinationMode('hierarchical')">🏗️ Hierarchical</div>
        <div style="margin-top: 15px; font-size: 0.7em; color: #ccc;">
            <div>Current: <span id="currentCoordinationMode">Parallel</span></div>
            <div>Active Agents: <span id="activeAgentCount">8</span></div>
        </div>
        <button onclick="toggleCoordinationPanel()" style="background: #666; border: none; color: white; padding: 6px 12px; border-radius: 4px; margin-top: 10px; cursor: pointer;">Close</button>
    </div>

    <script>
        class AgentOrchestrator {
            constructor() {
                this.agents = new Map([
                    ['tactical', { 
                        model: 'anthropic/claude-3.5-sonnet', 
                        specialty: 'strategic analysis and tactical coordination',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['science', { 
                        model: 'openai/gpt-4', 
                        specialty: 'pattern recognition and systematic investigation',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['ops', { 
                        model: 'meta-llama/llama-3.1-405b', 
                        specialty: 'systematic implementation and coordination',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['engineering', { 
                        model: 'google/gemini-pro', 
                        specialty: 'technical implementation and architecture',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['creative', { 
                        model: 'openai/gpt-4-turbo', 
                        specialty: 'creative synthesis and innovative solutions',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['research', { 
                        model: 'anthropic/claude-3-opus', 
                        specialty: 'research and knowledge synthesis',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['analysis', { 
                        model: 'mistralai/mixtral-8x7b-instruct', 
                        specialty: 'data analysis and quantitative assessment',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }],
                    ['support', { 
                        model: 'perplexity/llama-3.1-70b', 
                        specialty: 'system optimization and operational support',
                        status: 'ready',
                        responseTime: 0,
                        lastResponse: null
                    }]
                ]);
                
                this.config = {
                    apiKey: this.loadApiKey(),
                    apiEndpoint: 'https://openrouter.ai/api/v1/chat/completions',
                    mcpEndpoint: 'http://45.90.121.59:3030/api/mcp',
                    chaosEndpoint: 'http://45.90.121.59:3030/api/chaos',
                    throttleEndpoint: 'http://45.90.121.59:3030/api/throttle',
                    scalingEndpoint: 'http://45.90.121.59:3030/api/scaling',
                    moralEndpoint: 'http://45.90.121.59:3030/api/moral-recentering',
                    maxTokens: 2000,
                    temperature: 0.7,
                    parallelExecution: true,
                    synthesisMode: true,
                    useMCP: true,
                    chaosMode: true,
                    moralRecentering: true
                };
                
                this.metrics = {
                    totalRequests: 0,
                    requestsPerMin: 0,
                    errorRate: 0,
                    tokenUsage: 0,
                    estimatedCost: 0,
                    avgLatency: 0
                };
                
                this.secretsSources = new Map([
                    ['env', { active: true, priority: 1 }],
                    ['github', { active: false, priority: 2 }],
                    ['docker', { active: false, priority: 3 }],
                    ['local', { active: true, priority: 4 }]
                ]);
                
                // Advanced features
                this.coordinationMode = 'parallel';
                this.conversationMemory = new Map();
                this.healthStatus = new Map();
                this.performanceData = [];
                
                this.initializeSecrets();
                this.startMetricsMonitoring();
                this.startHealthMonitoring();
                this.initializePerformanceChart();
            }
            
            loadApiKey() {
                // Multi-layered secrets management
                const sources = [
                    () => process?.env?.OPENROUTER_API_KEY,
                    () => localStorage.getItem('openrouter_api_key'),
                    () => this.getGithubSecret('OPENROUTER_API_KEY'),
                    () => this.getDockerSecret('openrouter_api_key'),
                    () => this.promptUserForKey(), // Prompt user if no key found
                ];
                
                for (const source of sources) {
                    try {
                        const key = source();
                        if (key && key.startsWith('sk-or-') && key !== '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') {
                            this.log(`Using API key from secure source`, 'system');
                            return key;
                        }
                    } catch (e) {
                        continue;
                    }
                }
                
                // No valid key found - use demo mode
                this.log('⚠️ NO VALID API KEY FOUND - Operating in demo mode', 'error');
                this.log('💡 Add your OpenRouter API key to localStorage or environment variables', 'system');
                return null; // Return null to trigger demo mode
            }
            
            promptUserForKey() {
                const stored = localStorage.getItem('openrouter_api_key');
                if (stored && stored !== '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') {
                    return stored;
                }
                
                const userKey = prompt('Enter your OpenRouter API Key (get one from https://openrouter.ai/keys):');
                if (userKey && userKey.startsWith('sk-or-')) {
                    localStorage.setItem('openrouter_api_key', userKey);
                    this.log('API key saved to localStorage', 'system');
                    return userKey;
                }
                return null;
            }
            
            initializeSecrets() {
                // Check various secrets management systems
                try {
                    // Environment variables
                    if (typeof process !== 'undefined' && process.env) {
                        this.secretsSources.get('env').active = true;
                        document.getElementById('envSecrets').classList.add('active');
                    }
                    
                    // Local storage
                    if (localStorage.getItem('openrouter_api_key')) {
                        this.secretsSources.get('local').active = true;
                        document.getElementById('localSecrets').classList.add('active');
                    }
                    
                    // Docker secrets (simulated check)
                    this.checkDockerSecrets();
                    
                    // GitHub secrets (simulated check)  
                    this.checkGithubSecrets();
                    
                } catch (e) {
                    this.log('Secrets initialization failed: ' + e.message, 'error');
                }
            }
            
            checkDockerSecrets() {
                // Simulate Docker secrets check
                fetch('/run/secrets/openrouter_api_key').then(response => {
                    if (response.ok) {
                        this.secretsSources.get('docker').active = true;
                        document.getElementById('dockerSecrets').classList.add('active');
                    }
                }).catch(() => {});
            }
            
            checkGithubSecrets() {
                // Simulate GitHub Actions secrets access
                if (typeof process !== 'undefined' && process.env?.GITHUB_ACTIONS) {
                    this.secretsSources.get('github').active = true;
                    document.getElementById('githubSecrets').classList.add('active');
                }
            }
            
            getGithubSecret(name) {
                return process?.env?.[name] || null;
            }
            
            getDockerSecret(name) {
                // In a real implementation, this would read from /run/secrets/
                return null;
            }
            
            async executeSwarmCommand() {
                const prompt = document.getElementById('mainPrompt').value;
                if (!prompt.trim()) {
                    this.log('No command provided', 'error');
                    return;
                }
                
                this.log(`Executing swarm command: "${prompt.substring(0, 50)}..."`, 'system');
                this.updateMetrics({ totalRequests: this.metrics.totalRequests + 1 });
                
                const parallelMode = document.getElementById('parallelMode').checked;
                
                if (parallelMode) {
                    await this.executeParallel(prompt);
                } else {
                    await this.executeSequential(prompt);
                }
                
                if (document.getElementById('synthesisMode').checked) {
                    await this.synthesizeResponses();
                }
            }
            
            async executeParallel(prompt) {
                this.log('Executing throttled stream-based agent requests', 'system');
                
                const agentIds = Array.from(this.agents.keys());
                const throttleDelay = 2000; // 2 seconds between agent calls
                
                // Execute agents with throttled streaming
                for (let i = 0; i < agentIds.length; i++) {
                    const agentId = agentIds[i];
                    
                    // Add visible delay indicator
                    if (i > 0) {
                        this.showThrottleProgress(agentId, throttleDelay);
                        await this.sleep(throttleDelay);
                    }
                    
                    // Start agent call (non-blocking)
                    this.callAgentWithStream(agentId, prompt).catch(error => {
                        this.log(`Agent ${agentId} failed: ${error.message}`, 'error');
                    });
                    
                    // Small additional delay to prevent API rate limits
                    await this.sleep(500);
                }
            }
            
            showThrottleProgress(agentId, delay) {
                const statusEl = document.getElementById(`${agentId}Status`);
                const responseEl = document.getElementById(`${agentId}Response`);
                
                statusEl.textContent = 'WAITING';
                responseEl.textContent = `Throttled delay: ${delay/1000}s...`;
                
                let countdown = delay / 1000;
                const interval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        responseEl.textContent = `Throttled delay: ${countdown}s...`;
                    } else {
                        clearInterval(interval);
                        statusEl.textContent = 'READY';
                        responseEl.textContent = 'Ready for processing...';
                    }
                }, 1000);
            }
            
            async callAgentWithStream(agentId, prompt) {
                const agent = this.agents.get(agentId);
                const startTime = Date.now();
                
                this.updateAgentStatus(agentId, 'CONNECTING');
                this.updateAgentResponse(agentId, 'Establishing connection...');
                
                // Simulate connection delay
                await this.sleep(200);
                
                try {
                    this.updateAgentStatus(agentId, 'STREAMING');
                    this.updateAgentResponse(agentId, 'Streaming response...');
                    
                    const response = await this.makeStreamedAPICall(agent.model, prompt, agent.specialty, agentId);
                    
                    agent.lastResponse = response;
                    agent.responseTime = Date.now() - startTime;
                    
                    this.updateAgentStatus(agentId, 'COMPLETE');
                    
                    // Update metrics
                    this.updateMetrics({
                        tokenUsage: this.metrics.tokenUsage + this.estimateTokens(response),
                        avgLatency: (this.metrics.avgLatency + agent.responseTime) / 2
                    });
                    
                    this.log(`Agent ${agentId} completed in ${agent.responseTime}ms`, 'agent');
                    return response;
                } catch (error) {
                    this.updateAgentStatus(agentId, 'ERROR');
                    this.updateAgentResponse(agentId, `Error: ${error.message}`);
                    throw error;
                }
            }
            
            async makeStreamedAPICall(model, prompt, specialty, agentId) {
                // Use MCP endpoint if enabled
                if (this.config.useMCP) {
                    return this.callMCPEndpoint(model, prompt, specialty, agentId);
                }
                
                // Check if we have a valid API key for direct OpenRouter
                if (!this.config.apiKey || this.config.apiKey.includes('YOUR_ACTUAL_OPENROUTER_API_KEY_HERE')) {
                    return this.simulateStreamedResponse(model, prompt, specialty, agentId);
                }
                
                const systemPrompt = `You are a ${specialty} specialist in a multi-agent AI system. Provide focused, professional responses from your area of expertise.`;
                
                const requestBody = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: prompt }
                    ],
                    max_tokens: parseInt(document.getElementById('maxTokens').value),
                    temperature: parseFloat(document.getElementById('temperature').value),
                    stream: false // We'll simulate streaming on the client side
                };
                
                try {
                    const response = await fetch(this.config.apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.config.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Agent Orchestrator'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        this.log(`API Error ${response.status}: ${errorText}`, 'error');
                        
                        if (response.status === 401) {
                            throw new Error('Invalid API key - check your OpenRouter credentials');
                        } else if (response.status === 400) {
                            throw new Error(`Bad request - possibly unsupported model: ${model}`);
                        } else if (response.status === 429) {
                            throw new Error('Rate limit exceeded - wait and try again');
                        } else {
                            throw new Error(`API call failed: ${response.status} ${response.statusText}`);
                        }
                    }
                    
                    const data = await response.json();
                    const fullResponse = data.choices[0].message.content;
                    
                    // Simulate streaming effect by revealing response gradually
                    await this.streamResponseToUI(agentId, fullResponse);
                    
                    return fullResponse;
                } catch (error) {
                    this.log(`Network or API error: ${error.message}`, 'error');
                    
                    // Fallback to demo response if API fails
                    if (error.message.includes('Invalid API key') || error.message.includes('Bad request')) {
                        this.log('Falling back to demo response', 'system');
                        return this.simulateStreamedResponse(model, prompt, specialty, agentId);
                    }
                    throw error;
                }
            }
            
            async simulateStreamedResponse(model, prompt, specialty, agentId) {
                const demoResponse = this.getDemoResponse(model, prompt, specialty);
                await this.streamResponseToUI(agentId, demoResponse);
                return demoResponse;
            }
            
            async streamResponseToUI(agentId, fullResponse) {
                const responseEl = document.getElementById(`${agentId}Response`);
                const words = fullResponse.split(' ');
                const chunkSize = Math.max(1, Math.floor(words.length / 20)); // 20 chunks
                
                responseEl.textContent = '';
                
                for (let i = 0; i < words.length; i += chunkSize) {
                    const chunk = words.slice(i, i + chunkSize).join(' ');
                    const currentText = responseEl.textContent;
                    responseEl.textContent = currentText + (currentText ? ' ' : '') + chunk;
                    
                    // Scroll to keep response visible
                    responseEl.scrollTop = responseEl.scrollHeight;
                    
                    // Throttled delay between chunks
                    await this.sleep(150 + Math.random() * 100); // 150-250ms per chunk
                }
            }
            
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            async callMCPEndpoint(model, prompt, specialty, agentId) {
                try {
                    // Apply chaos engineering if enabled
                    if (this.config.chaosMode) {
                        await this.applyChaosEngineering(agentId);
                    }
                    
                    // Apply moral recentering
                    if (this.config.moralRecentering) {
                        prompt = await this.applyMoralRecentering(prompt, specialty);
                    }
                    
                    // Check throttling status
                    const throttleStatus = await this.checkThrottling(agentId);
                    if (throttleStatus.shouldThrottle) {
                        await this.sleep(throttleStatus.delay);
                    }
                    
                    const mcpRequest = {
                        method: 'llm_inference',
                        params: {
                            agent_id: agentId,
                            model: model,
                            specialty: specialty,
                            prompt: prompt,
                            max_tokens: this.config.maxTokens,
                            temperature: this.config.temperature,
                            use_rag: true,
                            context_window: 8192
                        }
                    };
                    
                    const response = await fetch(this.config.mcpEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Agent-ID': agentId,
                            'X-Specialty': specialty,
                            'X-Void-Shrine-Token': this.generateVoidShrineToken()
                        },
                        body: JSON.stringify(mcpRequest)
                    });
                    
                    if (!response.ok) {
                        // Fallback to direct OpenRouter or demo
                        this.log(`MCP endpoint failed, falling back: ${response.status}`, 'error');
                        return this.fallbackToOpenRouter(model, prompt, specialty, agentId);
                    }
                    
                    const data = await response.json();
                    
                    if (data.result && data.result.response) {
                        // Apply scaling adjustments
                        await this.applyScalingAdjustments(agentId, data.result.metrics);
                        
                        await this.streamResponseToUI(agentId, data.result.response);
                        return data.result.response;
                    } else {
                        throw new Error('Invalid MCP response format');
                    }
                    
                } catch (error) {
                    this.log(`MCP endpoint error: ${error.message}`, 'error');
                    return this.fallbackToOpenRouter(model, prompt, specialty, agentId);
                }
            }
            
            async applyChaosEngineering(agentId) {
                try {
                    const chaosResponse = await fetch(this.config.chaosEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            agent_id: agentId,
                            chaos_type: 'network_delay',
                            intensity: 0.3
                        })
                    });
                    
                    if (chaosResponse.ok) {
                        const chaos = await chaosResponse.json();
                        if (chaos.apply_chaos) {
                            this.log(`🌪️ Chaos applied to ${agentId}: ${chaos.effect}`, 'system');
                            await this.sleep(chaos.delay_ms || 0);
                        }
                    }
                } catch (e) {
                    // Chaos engineering failure is acceptable
                    this.log(`Chaos engineering unavailable`, 'system');
                }
            }
            
            async applyMoralRecentering(prompt, specialty) {
                try {
                    const moralResponse = await fetch(this.config.moralEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            original_prompt: prompt,
                            specialty: specialty,
                            void_shrine_context: true,
                            ethical_framework: 'care-ethics'
                        })
                    });
                    
                    if (moralResponse.ok) {
                        const moral = await moralResponse.json();
                        if (moral.recentered_prompt) {
                            this.log(`🧭 Moral recentering applied for ${specialty}`, 'system');
                            return moral.recentered_prompt;
                        }
                    }
                } catch (e) {
                    this.log(`Moral recentering unavailable, using original prompt`, 'system');
                }
                
                return prompt; // Return original if recentering fails
            }
            
            async checkThrottling(agentId) {
                try {
                    const throttleResponse = await fetch(`${this.config.throttleEndpoint}/${agentId}`, {
                        method: 'GET'
                    });
                    
                    if (throttleResponse.ok) {
                        const throttle = await throttleResponse.json();
                        return {
                            shouldThrottle: throttle.should_throttle,
                            delay: throttle.delay_ms || 0,
                            reason: throttle.reason
                        };
                    }
                } catch (e) {
                    this.log(`Throttling service unavailable`, 'system');
                }
                
                return { shouldThrottle: false, delay: 0 };
            }
            
            async applyScalingAdjustments(agentId, metrics) {
                try {
                    const scalingResponse = await fetch(this.config.scalingEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            agent_id: agentId,
                            response_time: metrics?.response_time_ms,
                            token_count: metrics?.token_count,
                            success: true
                        })
                    });
                    
                    if (scalingResponse.ok) {
                        const scaling = await scalingResponse.json();
                        if (scaling.adjustments) {
                            this.log(`⚖️ Scaling adjustments: ${scaling.adjustments.description}`, 'system');
                        }
                    }
                } catch (e) {
                    // Scaling adjustment failure is non-critical
                }
            }
            
            generateVoidShrineToken() {
                const timestamp = Date.now();
                const entropy = Math.random().toString(36).substring(2);
                return `vs_${timestamp}_${entropy}`;
            }
            
            async fallbackToOpenRouter(model, prompt, specialty, agentId) {
                this.log(`Using OpenRouter fallback for ${agentId}`, 'system');
                
                // Temporarily disable MCP to use direct OpenRouter
                const originalUseMCP = this.config.useMCP;
                this.config.useMCP = false;
                
                try {
                    const result = await this.makeStreamedAPICall(model, prompt, specialty, agentId);
                    return result;
                } finally {
                    this.config.useMCP = originalUseMCP;
                }
            }
            
            async executeSequential(prompt) {
                this.log('Executing sequential agent requests', 'system');
                
                for (const agentId of this.agents.keys()) {
                    try {
                        await this.callAgent(agentId, prompt);
                        this.log(`Agent ${agentId} completed`, 'agent');
                    } catch (error) {
                        this.log(`Agent ${agentId} failed: ${error.message}`, 'error');
                    }
                }
            }
            
            async callAgent(agentId, prompt) {
                const agent = this.agents.get(agentId);
                const startTime = Date.now();
                
                this.updateAgentStatus(agentId, 'PROCESSING');
                
                try {
                    const response = await this.makeAPICall(agent.model, prompt, agent.specialty);
                    
                    agent.lastResponse = response;
                    agent.responseTime = Date.now() - startTime;
                    
                    this.updateAgentResponse(agentId, response);
                    this.updateAgentStatus(agentId, 'COMPLETE');
                    
                    // Add to conversation memory
                    this.addToMemory(agentId, prompt, response);
                    
                    // Update metrics
                    this.updateMetrics({
                        tokenUsage: this.metrics.tokenUsage + this.estimateTokens(response),
                        avgLatency: (this.metrics.avgLatency + agent.responseTime) / 2
                    });
                    
                    return response;
                } catch (error) {
                    this.updateAgentStatus(agentId, 'ERROR');
                    this.updateAgentResponse(agentId, `Error: ${error.message}`);
                    throw error;
                }
            }
            
            async makeAPICall(model, prompt, specialty) {
                // Check if we have a valid API key
                if (!this.config.apiKey || this.config.apiKey.includes('YOUR_ACTUAL_OPENROUTER_API_KEY_HERE')) {
                    return this.getDemoResponse(model, prompt, specialty);
                }
                
                const systemPrompt = `You are a ${specialty} specialist in a multi-agent AI system. Provide focused, professional responses from your area of expertise.`;
                
                const requestBody = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: prompt }
                    ],
                    max_tokens: parseInt(document.getElementById('maxTokens').value),
                    temperature: parseFloat(document.getElementById('temperature').value),
                    stream: false
                };
                
                try {
                    const response = await fetch(this.config.apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.config.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Agent Orchestrator'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        this.log(`API Error ${response.status}: ${errorText}`, 'error');
                        
                        if (response.status === 401) {
                            throw new Error('Invalid API key - check your OpenRouter credentials');
                        } else if (response.status === 400) {
                            throw new Error(`Bad request - possibly unsupported model: ${model}`);
                        } else if (response.status === 429) {
                            throw new Error('Rate limit exceeded - wait and try again');
                        } else {
                            throw new Error(`API call failed: ${response.status} ${response.statusText}`);
                        }
                    }
                    
                    const data = await response.json();
                    return data.choices[0].message.content;
                } catch (error) {
                    this.log(`Network or API error: ${error.message}`, 'error');
                    
                    // Fallback to demo response if API fails
                    if (error.message.includes('Invalid API key') || error.message.includes('Bad request')) {
                        this.log('Falling back to demo response', 'system');
                        return this.getDemoResponse(model, prompt, specialty);
                    }
                    throw error;
                }
            }
            
            getDemoResponse(model, prompt, specialty) {
                const demoResponses = {
                    'anthropic/claude-3.5-sonnet': `[DEMO MODE] As a tactical coordinator, I analyze the situation with strategic precision. Your prompt "${prompt.substring(0, 50)}..." requires systematic assessment of resources and optimal deployment strategies.`,
                    'openai/gpt-4': `[DEMO MODE] From a scientific analysis perspective, this problem requires methodical investigation. I would approach "${prompt.substring(0, 50)}..." through hypothesis formation and evidence-based reasoning.`,
                    'meta-llama/llama-3.1-405b': `[DEMO MODE] Operations analysis indicates multiple implementation vectors for "${prompt.substring(0, 50)}...". Coordinating systematic execution across operational domains.`,
                    'google/gemini-pro': `[DEMO MODE] Engineering assessment complete. Technical implementation for "${prompt.substring(0, 50)}..." requires scalable architecture and robust system design principles.`,
                    'openai/gpt-4-turbo': `[DEMO MODE] Creative synthesis engaging. Novel approaches to "${prompt.substring(0, 50)}..." involve innovative perspective generation and artistic problem-solving methodologies.`,
                    'anthropic/claude-3-opus': `[DEMO MODE] Research protocols active. Deep investigation of "${prompt.substring(0, 50)}..." requires comprehensive knowledge synthesis across multiple domains.`,
                    'mistralai/mixtral-8x7b-instruct': `[DEMO MODE] Statistical analysis framework deployed. Quantitative assessment of "${prompt.substring(0, 50)}..." involves data processing and trend identification protocols.`,
                    'perplexity/llama-3.1-70b': `[DEMO MODE] Support systems monitoring complete. Performance optimization for "${prompt.substring(0, 50)}..." ensures operational resilience and system health.`
                };
                
                return demoResponses[model] || `[DEMO MODE] ${specialty} response to: "${prompt.substring(0, 50)}..." - This is a demonstration response. Add a valid OpenRouter API key for real AI responses.`;
            }
            
            async synthesizeResponses() {
                this.log('Synthesizing agent responses', 'system');
                
                const responses = Array.from(this.agents.values())
                    .filter(agent => agent.lastResponse)
                    .map(agent => agent.lastResponse);
                
                if (responses.length === 0) {
                    this.log('No responses to synthesize', 'system');
                    return;
                }
                
                const synthesisPrompt = `Synthesize these agent responses into a coherent analysis:\n\n${responses.join('\n\n---\n\n')}`;
                
                try {
                    const synthesis = await this.makeAPICall('anthropic/claude-3.5-sonnet', synthesisPrompt, 'synthesis coordination');
                    
                    // Display synthesis result
                    const synthesisDiv = document.createElement('div');
                    synthesisDiv.style.cssText = `
                        background: rgba(138, 43, 226, 0.1);
                        border: 2px solid #8a2be2;
                        border-radius: 10px;
                        padding: 15px;
                        margin: 10px;
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        max-width: 80%;
                        max-height: 70%;
                        overflow-y: auto;
                        z-index: 1000;
                        color: #e0e0ff;
                        font-size: 0.9em;
                        line-height: 1.4;
                    `;
                    
                    synthesisDiv.innerHTML = `
                        <h3 style="color: #8a2be2; margin-bottom: 15px;">🌟 Swarm Synthesis</h3>
                        <div>${synthesis.replace(/\n/g, '<br>')}</div>
                        <button onclick="this.parentElement.remove()" style="
                            background: #8a2be2;
                            border: none;
                            color: white;
                            padding: 8px 16px;
                            border-radius: 5px;
                            margin-top: 15px;
                            cursor: pointer;
                        ">Close</button>
                    `;
                    
                    document.body.appendChild(synthesisDiv);
                    
                } catch (error) {
                    this.log(`Synthesis failed: ${error.message}`, 'error');
                }
            }
            
            updateAgentStatus(agentId, status) {
                const agent = this.agents.get(agentId);
                agent.status = status;
                document.getElementById(`${agentId}Status`).textContent = status;
            }
            
            updateAgentResponse(agentId, response) {
                document.getElementById(`${agentId}Response`).textContent = response;
            }
            
            updateMetrics(updates) {
                Object.assign(this.metrics, updates);
                
                document.getElementById('totalRequests').textContent = this.metrics.totalRequests;
                document.getElementById('avgLatency').textContent = `${this.metrics.avgLatency.toFixed(0)}ms`;
                document.getElementById('tokenUsage').textContent = `${(this.metrics.tokenUsage / 1000).toFixed(1)}K`;
                document.getElementById('costEstimate').textContent = `$${this.metrics.estimatedCost.toFixed(2)}`;
            }
            
            estimateTokens(text) {
                // Rough token estimation
                return Math.ceil(text.length / 4);
            }
            
            startMetricsMonitoring() {
                setInterval(() => {
                    // Update metrics periodically
                    const activeCount = Array.from(this.agents.values()).filter(a => a.status === 'ready').length;
                    document.getElementById('activeAgents').textContent = activeCount;
                    
                    // Simulate coherence calculation
                    const coherence = Math.max(60, 100 - (this.metrics.errorRate * 10));
                    document.getElementById('coherence').textContent = `${coherence.toFixed(0)}%`;
                }, 2000);
            }
            
            log(message, type = 'system') {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                
                const logDisplay = document.getElementById('activityLog');
                logDisplay.appendChild(logEntry);
                logDisplay.scrollTop = logDisplay.scrollHeight;
                
                // Keep only last 50 entries
                while (logDisplay.children.length > 50) {
                    logDisplay.removeChild(logDisplay.firstChild);
                }
            }
            
            // Advanced coordination methods
            async executeCoordinationMode(prompt) {
                switch (this.coordinationMode) {
                    case 'sequential':
                        return this.executeSequential(prompt);
                    case 'parallel':
                        return this.executeParallel(prompt);
                    case 'pipeline':
                        return this.executePipeline(prompt);
                    case 'consensus':
                        return this.executeConsensus(prompt);
                    case 'competitive':
                        return this.executeCompetitive(prompt);
                    case 'hierarchical':
                        return this.executeHierarchical(prompt);
                    default:
                        return this.executeParallel(prompt);
                }
            }
            
            async executePipeline(prompt) {
                this.log('🔗 Executing pipeline coordination', 'system');
                
                const pipeline = ['tactical', 'science', 'engineering', 'operations'];
                let currentPrompt = prompt;
                
                for (const agentId of pipeline) {
                    try {
                        const response = await this.callAgentWithStream(agentId, currentPrompt);
                        currentPrompt = `Building on previous analysis: ${response.substring(0, 200)}...\n\nNew task: ${prompt}`;
                        await this.sleep(1000); // Pipeline delay
                    } catch (error) {
                        this.log(`Pipeline broken at ${agentId}: ${error.message}`, 'error');
                        break;
                    }
                }
            }
            
            async executeConsensus(prompt) {
                this.log('🤝 Executing consensus coordination', 'system');
                
                const primaryAgents = ['tactical', 'science', 'engineering'];
                const responses = [];
                
                // Get initial responses
                for (const agentId of primaryAgents) {
                    try {
                        const response = await this.callAgentWithStream(agentId, prompt);
                        responses.push({agentId, response});
                    } catch (error) {
                        this.log(`Consensus agent ${agentId} failed: ${error.message}`, 'error');
                    }
                }
                
                // Synthesis for consensus
                if (responses.length > 1) {
                    const consensusPrompt = `Review these responses and identify consensus points: ${responses.map(r => r.response.substring(0, 100)).join('; ')}`;
                    await this.callAgentWithStream('research', consensusPrompt);
                }
            }
            
            async executeCompetitive(prompt) {
                this.log('🏆 Executing competitive coordination', 'system');
                
                const competitors = ['tactical', 'science', 'creative', 'analysis'];
                const startTime = Date.now();
                
                const promises = competitors.map(agentId => 
                    this.callAgentWithStream(agentId, `Compete to provide the best response: ${prompt}`)
                        .then(response => ({agentId, response, time: Date.now() - startTime}))
                        .catch(error => ({agentId, error: error.message, time: Date.now() - startTime}))
                );
                
                const results = await Promise.allSettled(promises);
                const winner = results
                    .filter(r => r.status === 'fulfilled' && !r.value.error)
                    .sort((a, b) => a.value.time - b.value.time)[0];
                
                if (winner) {
                    this.log(`🏆 Competition winner: ${winner.value.agentId} (${winner.value.time}ms)`, 'agent');
                }
            }
            
            async executeHierarchical(prompt) {
                this.log('🏗️ Executing hierarchical coordination', 'system');
                
                // Strategic level
                const strategic = await this.callAgentWithStream('tactical', `Strategic overview needed: ${prompt}`);
                
                // Tactical level
                const tactical = await Promise.allSettled([
                    this.callAgentWithStream('science', `Scientific analysis for: ${prompt}`),
                    this.callAgentWithStream('engineering', `Technical implementation for: ${prompt}`)
                ]);
                
                // Operational level
                await Promise.allSettled([
                    this.callAgentWithStream('operations', `Execute based on strategic plan: ${strategic.substring(0, 100)}...`),
                    this.callAgentWithStream('support', `Support requirements for: ${prompt}`)
                ]);
            }
            
            // Health monitoring
            startHealthMonitoring() {
                setInterval(async () => {
                    await this.checkSystemHealth();
                }, 5000); // Check every 5 seconds
            }
            
            async checkSystemHealth() {
                // Check MCP service
                try {
                    const mcpResponse = await fetch(this.config.mcpEndpoint.replace('/mcp', '/throttle/health'), {method: 'GET', signal: AbortSignal.timeout(2000)});
                    this.updateHealthIndicator('mcpHealth', mcpResponse.ok);
                } catch {
                    this.updateHealthIndicator('mcpHealth', false);
                }
                
                // Check other services (simulated)
                this.updateHealthIndicator('ragHealth', true);
                this.updateHealthIndicator('chaosHealth', this.config.chaosMode);
                this.updateHealthIndicator('moralHealth', this.config.moralRecentering);
            }
            
            updateHealthIndicator(elementId, isHealthy) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.className = `health-dot ${isHealthy ? 'healthy' : ''}`;
                }
            }
            
            // Performance chart
            initializePerformanceChart() {
                const canvas = document.getElementById('performanceChart');
                const ctx = canvas.getContext('2d');
                
                setInterval(() => {
                    this.updatePerformanceChart(ctx, canvas);
                }, 1000);
            }
            
            updatePerformanceChart(ctx, canvas) {
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Add current metrics
                this.performanceData.push({
                    timestamp: Date.now(),
                    requests: this.metrics.totalRequests,
                    latency: this.metrics.avgLatency,
                    errorRate: this.metrics.errorRate
                });
                
                // Keep last 50 data points
                if (this.performanceData.length > 50) {
                    this.performanceData.shift();
                }
                
                if (this.performanceData.length < 2) return;
                
                // Draw latency line
                ctx.strokeStyle = '#00ffaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                this.performanceData.forEach((point, index) => {
                    const x = (index / this.performanceData.length) * width;
                    const y = height - (Math.min(point.latency, 5000) / 5000) * height;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }
            
            // Conversation memory
            addToMemory(agentId, prompt, response) {
                if (!this.conversationMemory.has(agentId)) {
                    this.conversationMemory.set(agentId, []);
                }
                
                const memory = this.conversationMemory.get(agentId);
                memory.push({
                    timestamp: new Date().toISOString(),
                    prompt: prompt.substring(0, 50) + '...',
                    response: response.substring(0, 100) + '...'
                });
                
                // Keep last 5 interactions
                if (memory.length > 5) {
                    memory.shift();
                }
                
                this.updateMemoryDisplay(agentId, memory);
            }
            
            updateMemoryDisplay(agentId, memory) {
                const memoryElement = document.getElementById(`${agentId}Memory`);
                if (memoryElement) {
                    memoryElement.innerHTML = memory.map((entry, index) => 
                        `<div class="memory-entry">💭 ${index + 1}: ${entry.prompt} → ${entry.response}</div>`
                    ).join('');
                }
            }
        }
        
        // Global functions
        function focusAgent(agentId) {
            orchestrator.log(`Focusing on ${agentId} agent`, 'agent');
            const station = document.querySelector(`.${agentId}`);
            station.style.transform = 'scale(1.05)';
            station.style.boxShadow = '0 0 40px rgba(var(--agent-rgb), 0.8)';
            setTimeout(() => {
                station.style.transform = '';
                station.style.boxShadow = '0 0 20px rgba(var(--agent-rgb), 0.2)';
            }, 2000);
        }
        
        function resetAgent(agentId) {
            orchestrator.log(`Resetting ${agentId} agent`, 'system');
            orchestrator.updateAgentStatus(agentId, 'READY');
            orchestrator.agents.get(agentId).lastResponse = null;
            document.getElementById(`${agentId}Response`).textContent = 'Agent reset - ready for new commands';
        }
        
        function testAgent(agentId) {
            orchestrator.log(`Testing ${agentId} agent`, 'system');
            orchestrator.callAgent(agentId, 'Perform a brief self-diagnostic and confirm operational status');
        }
        
        function executeSwarmCommand() {
            orchestrator.executeCoordinationMode(document.getElementById('mainPrompt').value);
        }
        
        function toggleCoordinationPanel() {
            const panel = document.getElementById('coordinationPanel');
            panel.style.display = panel.style.display === 'none' || !panel.style.display ? 'block' : 'none';
        }
        
        function setCoordinationMode(mode) {
            orchestrator.coordinationMode = mode;
            document.getElementById('currentCoordinationMode').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
            
            // Update UI
            document.querySelectorAll('.coordination-mode').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
            
            orchestrator.log(`🎛️ Coordination mode set to: ${mode}`, 'system');
        }
        
        function exportConfiguration() {
            const config = {
                agents: Array.from(orchestrator.agents.entries()),
                coordinationMode: orchestrator.coordinationMode,
                config: orchestrator.config,
                conversationMemory: Array.from(orchestrator.conversationMemory.entries()),
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `void-shrine-config-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            orchestrator.log('💾 Configuration exported', 'system');
        }
        
        function showConfigPanel() {
            const panel = document.createElement('div');
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid #8a2be2;
                border-radius: 15px;
                padding: 20px;
                max-width: 500px;
                z-index: 1000;
                color: #e0e0ff;
            `;
            
            const currentKey = localStorage.getItem('openrouter_api_key') || '';
            const isValidKey = currentKey && currentKey.startsWith('sk-or-') && currentKey !== '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';
            
            panel.innerHTML = `
                <h3 style="color: #8a2be2; margin-bottom: 15px;">🔐 API Configuration</h3>
                <p style="font-size: 0.85em; margin-bottom: 15px; line-height: 1.4;">
                    To use real AI agents, you need a valid OpenRouter API key.<br>
                    Get one from: <a href="https://openrouter.ai/keys" target="_blank" style="color: #00ffaa;">https://openrouter.ai/keys</a>
                </p>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">OpenRouter API Key:</label>
                    <input type="password" id="configApiKey" value="${currentKey}" 
                           style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #666; 
                                  color: #e0e0ff; padding: 8px; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 0.7em; margin-top: 5px; color: ${isValidKey ? '#00ffaa' : '#ff4444'};">
                        Status: ${isValidKey ? 'Valid Key Format' : 'No valid key found'}
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <p style="font-size: 0.75em; color: #ffaa00;">
                        ⚠️ Known Issues:<br>
                        • Gemini Pro: May not be available on your OpenRouter plan<br>
                        • Perplexity 70B: Requires specific model access<br>
                        • Some models need premium OpenRouter subscription
                    </p>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: #666; border: none; color: white; padding: 8px 16px; 
                                   border-radius: 5px; cursor: pointer;">Cancel</button>
                    <button onclick="saveApiKey(); this.parentElement.parentElement.remove();" 
                            style="background: #8a2be2; border: none; color: white; padding: 8px 16px; 
                                   border-radius: 5px; cursor: pointer;">Save</button>
                </div>
            `;
            
            document.body.appendChild(panel);
        }
        
        function saveApiKey() {
            const keyInput = document.getElementById('configApiKey');
            const newKey = keyInput.value.trim();
            
            if (newKey && newKey.startsWith('sk-or-')) {
                localStorage.setItem('openrouter_api_key', newKey);
                orchestrator.config.apiKey = newKey;
                orchestrator.log('API key updated successfully', 'system');
                updateApiKeyStatus();
            } else {
                orchestrator.log('Invalid API key format', 'error');
            }
        }
        
        function updateApiKeyStatus() {
            const statusEl = document.getElementById('apiKeyStatus');
            const currentKey = orchestrator.config.apiKey;
            
            if (!currentKey || currentKey.includes('YOUR_ACTUAL_OPENROUTER_API_KEY_HERE')) {
                statusEl.textContent = 'Demo Mode';
                statusEl.style.color = '#ffaa00';
            } else if (currentKey.startsWith('sk-or-') && currentKey !== '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') {
                statusEl.textContent = 'Valid Key';
                statusEl.style.color = '#00ffaa';
            } else {
                statusEl.textContent = 'Invalid Key';
                statusEl.style.color = '#ff4444';
            }
        }
        
        function executeSwarmCommand() {
            orchestrator.executeSwarmCommand();
        }
        
        // Orchestration Scenarios for Testing
        const orchestrationScenarios = [
            {
                name: "Strategic Crisis Response",
                description: "Multi-agent crisis analysis and response planning",
                prompt: "A major supply chain disruption has occurred affecting multiple industries. Provide comprehensive analysis and response strategies.",
                expectedAgents: ['tactical', 'science', 'ops', 'engineering'],
                successMetrics: {
                    minResponseTime: 5000,
                    maxResponseTime: 30000,
                    requiredAgents: 4,
                    coherenceThreshold: 0.7
                }
            },
            {
                name: "Technical Architecture Design",
                description: "Collaborative system architecture planning",
                prompt: "Design a scalable microservices architecture for a high-traffic e-commerce platform with real-time analytics.",
                expectedAgents: ['engineering', 'science', 'ops', 'analysis'],
                successMetrics: {
                    minResponseTime: 3000,
                    maxResponseTime: 25000,
                    requiredAgents: 4,
                    coherenceThreshold: 0.8
                }
            },
            {
                name: "Creative Problem Solving",
                description: "Innovation-focused multi-perspective analysis",
                prompt: "How can we reimagine urban transportation to be more sustainable and efficient?",
                expectedAgents: ['creative', 'science', 'engineering', 'research'],
                successMetrics: {
                    minResponseTime: 4000,
                    maxResponseTime: 35000,
                    requiredAgents: 4,
                    coherenceThreshold: 0.6
                }
            },
            {
                name: "Data Analysis Workflow",
                description: "End-to-end data processing and insights",
                prompt: "Analyze patterns in customer behavior data and recommend optimization strategies for user engagement.",
                expectedAgents: ['analysis', 'science', 'tactical', 'support'],
                successMetrics: {
                    minResponseTime: 3000,
                    maxResponseTime: 20000,
                    requiredAgents: 4,
                    coherenceThreshold: 0.8
                }
            },
            {
                name: "Research Synthesis",
                description: "Comprehensive knowledge integration",
                prompt: "Synthesize current research on artificial intelligence safety and provide actionable recommendations.",
                expectedAgents: ['research', 'science', 'tactical', 'analysis'],
                successMetrics: {
                    minResponseTime: 5000,
                    maxResponseTime: 40000,
                    requiredAgents: 4,
                    coherenceThreshold: 0.9
                }
            }
        ];

        // Agent-specific prompt tests
        const agentPromptTests = {
            tactical: [
                "Analyze the strategic implications of implementing a new customer acquisition strategy",
                "Assess the tactical risks of entering a new market with limited resources",
                "Develop a resource allocation plan for a multi-phase project rollout"
            ],
            science: [
                "Identify patterns in this dataset: [1,3,5,8,13,21,34]. What's the underlying structure?",
                "Analyze the correlation between user engagement metrics and retention rates",
                "Investigate anomalies in system performance data over the last month"
            ],
            ops: [
                "Coordinate the deployment of a microservices architecture across multiple environments",
                "Implement a monitoring system for distributed applications with automatic scaling",
                "Execute a zero-downtime migration of critical database systems"
            ],
            engineering: [
                "Design a fault-tolerant distributed computing system for real-time data processing",
                "Architect a secure API gateway with rate limiting and authentication",
                "Build a scalable event-driven architecture for high-volume transactions"
            ],
            creative: [
                "Generate innovative approaches to visualizing complex financial data",
                "Design a user experience that makes advanced analytics accessible to non-experts",
                "Create novel interaction paradigms for multi-dimensional data exploration"
            ],
            research: [
                "Synthesize current literature on distributed systems consensus algorithms",
                "Investigate emerging trends in machine learning interpretability methods",
                "Analyze the evolution of API design patterns over the last decade"
            ],
            analysis: [
                "Perform statistical analysis on user behavior patterns to identify optimization opportunities",
                "Calculate the ROI impact of implementing advanced caching strategies",
                "Quantify the performance improvements from database query optimization"
            ],
            support: [
                "Monitor system health metrics and identify potential bottlenecks before they impact users",
                "Optimize resource utilization across containerized workloads for cost efficiency",
                "Implement automated failover procedures for critical system components"
            ]
        };

        async function runOrchestrationScenarios() {
            orchestrator.log('🎭 Starting orchestration scenario testing', 'system');
            
            const scenarioResults = [];
            
            for (let i = 0; i < orchestrationScenarios.length; i++) {
                const scenario = orchestrationScenarios[i];
                orchestrator.log(`Testing scenario ${i + 1}: ${scenario.name}`, 'system');
                
                const startTime = Date.now();
                
                // Set the prompt
                document.getElementById('mainPrompt').value = scenario.prompt;
                
                // Execute the scenario
                try {
                    await orchestrator.executeSwarmCommand();
                    
                    const endTime = Date.now();
                    const duration = endTime - startTime;
                    
                    const result = {
                        name: scenario.name,
                        success: duration >= scenario.successMetrics.minResponseTime && 
                                duration <= scenario.successMetrics.maxResponseTime,
                        duration: duration,
                        timestamp: new Date().toISOString()
                    };
                    
                    scenarioResults.push(result);
                    
                    orchestrator.log(`Scenario "${scenario.name}": ${result.success ? '✅ PASS' : '❌ FAIL'} (${duration}ms)`, 
                                   result.success ? 'agent' : 'error');
                    
                } catch (error) {
                    orchestrator.log(`Scenario "${scenario.name}" failed: ${error.message}`, 'error');
                    scenarioResults.push({
                        name: scenario.name,
                        success: false,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
                
                // Wait between scenarios to prevent rate limiting
                await orchestrator.sleep(3000);
            }
            
            // Display results summary
            showScenarioResults(scenarioResults);
        }

        async function runPromptTests() {
            orchestrator.log('🧪 Starting agent-specific prompt tests', 'system');
            
            const testResults = {};
            
            for (const [agentId, prompts] of Object.entries(agentPromptTests)) {
                orchestrator.log(`Testing agent: ${agentId}`, 'system');
                testResults[agentId] = [];
                
                for (let i = 0; i < prompts.length; i++) {
                    const prompt = prompts[i];
                    const startTime = Date.now();
                    
                    try {
                        orchestrator.log(`${agentId} test ${i + 1}: ${prompt.substring(0, 50)}...`, 'system');
                        await orchestrator.callAgentWithStream(agentId, prompt);
                        
                        const duration = Date.now() - startTime;
                        testResults[agentId].push({
                            prompt: prompt.substring(0, 50) + '...',
                            success: true,
                            duration: duration
                        });
                        
                        orchestrator.log(`${agentId} test ${i + 1}: ✅ PASS (${duration}ms)`, 'agent');
                        
                    } catch (error) {
                        testResults[agentId].push({
                            prompt: prompt.substring(0, 50) + '...',
                            success: false,
                            error: error.message
                        });
                        
                        orchestrator.log(`${agentId} test ${i + 1}: ❌ FAIL - ${error.message}`, 'error');
                    }
                    
                    // Throttle between tests
                    await orchestrator.sleep(2000);
                }
                
                // Wait between agents
                await orchestrator.sleep(1000);
            }
            
            showPromptTestResults(testResults);
        }

        function showScenarioResults(results) {
            const panel = document.createElement('div');
            panel.style.cssText = `
                position: fixed;
                top: 10%;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid #ff6b6b;
                border-radius: 15px;
                padding: 20px;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                z-index: 1000;
                color: #e0e0ff;
            `;
            
            const successCount = results.filter(r => r.success).length;
            const totalCount = results.length;
            
            panel.innerHTML = `
                <h3 style="color: #ff6b6b; margin-bottom: 15px;">🎭 Orchestration Scenario Results</h3>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(0,255,170,0.1); border-radius: 5px;">
                    <strong>Success Rate: ${successCount}/${totalCount} (${Math.round(successCount/totalCount*100)}%)</strong>
                </div>
                ${results.map(result => `
                    <div style="margin: 10px 0; padding: 10px; background: rgba(${result.success ? '0,255,170' : '255,68,68'},0.1); border-radius: 5px;">
                        <div style="font-weight: bold; color: ${result.success ? '#00ffaa' : '#ff4444'};">
                            ${result.success ? '✅' : '❌'} ${result.name}
                        </div>
                        <div style="font-size: 0.8em; margin-top: 5px;">
                            ${result.duration ? `Duration: ${result.duration}ms` : ''}
                            ${result.error ? `Error: ${result.error}` : ''}
                        </div>
                    </div>
                `).join('')}
                <button onclick="this.parentElement.remove()" style="
                    background: #ff6b6b; border: none; color: white; padding: 8px 16px;
                    border-radius: 5px; margin-top: 15px; cursor: pointer;">Close</button>
            `;
            
            document.body.appendChild(panel);
        }

        function showPromptTestResults(results) {
            const panel = document.createElement('div');
            panel.style.cssText = `
                position: fixed;
                top: 10%;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid #00ffaa;
                border-radius: 15px;
                padding: 20px;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                z-index: 1000;
                color: #e0e0ff;
            `;
            
            const allTests = Object.values(results).flat();
            const successCount = allTests.filter(t => t.success).length;
            const totalCount = allTests.length;
            
            panel.innerHTML = `
                <h3 style="color: #00ffaa; margin-bottom: 15px;">🧪 Agent Prompt Test Results</h3>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(138,43,226,0.1); border-radius: 5px;">
                    <strong>Overall Success Rate: ${successCount}/${totalCount} (${Math.round(successCount/totalCount*100)}%)</strong>
                </div>
                ${Object.entries(results).map(([agentId, tests]) => {
                    const agentSuccess = tests.filter(t => t.success).length;
                    const agentTotal = tests.length;
                    return `
                        <div style="margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <h4 style="color: #8a2be2; margin-bottom: 10px;">
                                🤖 ${agentId.toUpperCase()} - ${agentSuccess}/${agentTotal} passed
                            </h4>
                            ${tests.map(test => `
                                <div style="margin: 5px 0; padding: 5px; background: rgba(${test.success ? '0,255,170' : '255,68,68'},0.1); border-radius: 3px;">
                                    <span style="color: ${test.success ? '#00ffaa' : '#ff4444'};">
                                        ${test.success ? '✅' : '❌'} ${test.prompt}
                                    </span>
                                    ${test.duration ? `<span style="font-size: 0.7em; margin-left: 10px;">(${test.duration}ms)</span>` : ''}
                                    ${test.error ? `<div style="font-size: 0.7em; color: #ff4444; margin-top: 2px;">${test.error}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }).join('')}
                <button onclick="this.parentElement.remove()" style="
                    background: #00ffaa; border: none; color: black; padding: 8px 16px;
                    border-radius: 5px; margin-top: 15px; cursor: pointer;">Close</button>
            `;
            
            document.body.appendChild(panel);
        }

        // Initialize orchestrator
        const orchestrator = new AgentOrchestrator();
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                executeSwarmCommand();
            }
        });
        
        // Demo initialization
        setTimeout(() => {
            orchestrator.log('🌀 Agent Orchestrator fully operational', 'system');
            orchestrator.log('🤖 8 AI agents ready for multi-model coordination', 'system');
            orchestrator.log('🔐 Secrets management systems active', 'system');
            orchestrator.log('🚀 Ready for swarm intelligence deployment', 'system');
            updateApiKeyStatus(); // Update API key status on load
        }, 1000);
        
        console.log('🌀 Multi-LLM Agent Orchestrator initialized');
        console.log('🤖 Available models: Claude 3.5, GPT-4, Llama 3.1, Gemini Pro, and more');
        console.log('🔐 Multi-layered secrets management active');
        console.log('⚡ Press Ctrl+Enter to execute swarm commands');
    </script>
</body>
</html>